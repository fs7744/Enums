using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Operations;
using System;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Threading;

namespace SV.Analyzers
{
    [Generator]
    public class EnumInfoGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var nodes = context.SyntaxProvider.CreateSyntaxProvider(FilterEnum, TransformEnum)
                .Where(x => x is not null)
                    .Select((x, _) => x!);
            var combined = context.CompilationProvider.Combine(nodes.Collect());
            context.RegisterImplementationSourceOutput(combined, Generate);
        }

        private void Generate(SourceProductionContext context, (Compilation Compilation, ImmutableArray<INamedTypeSymbol> Enums) state)
        {
            try
            {
                var es = state.Enums.Select(GenerateEnumInfo).ToArray();
                var src = $@"
// <auto-generated/>
#pragma warning disable 8019 //disable 'unnecessary using directive' warning
using System;
using System.Runtime.CompilerServices;
using System.ComponentModel;

namespace SV
{{

//#if NET5_0_OR_GREATER

    {string.Join("\r\n", es.Select(i => i.Content))}
    internal static partial class Enums{Guid.NewGuid().ToString("N").ToUpper()}
    {{
        [ModuleInitializer]
        internal static void Init{Guid.NewGuid().ToString("N").ToUpper()}()
        {{
            {string.Join("\r\n", es.Select(i => i.Set))}
        }}
    }}
//#else
//#endif
}}
            ";

                context.AddSource((state.Compilation.AssemblyName ?? "package") + ".generated.cs", src);
            }
            catch (Exception ex)
            {
                Debug.Fail(ex.Message);
            }
        }
        
        private (string Set, string Content) GenerateEnumInfo(INamedTypeSymbol symbol)
        {
            var name = $"EnumInfo{Guid.NewGuid().ToString("N").ToUpper()}";
            var tn = $"global::{symbol.ToDisplayString()}";

            var enumMembers = symbol.GetMembers().Where(i => i is IFieldSymbol field && field.ConstantValue is not null).ToArray();

            var src = @$"
    internal class {name} : EnumBase<{tn}>
    {{
        public override bool IsDefined(string name)
        {{
            return name switch
            {{
                {string.Join("\r\n", enumMembers.Select(i => $"nameof({tn}.{i.Name}) => true,"))}
                _ => false,
            }};
        }}

        public override string? GetName({tn} t)
        {{
            switch (t)
            {{
                {string.Join("\r\n", enumMembers.Select(i => $"case {tn}.{i.Name}: return nameof({tn}.{i.Name});"))}
                default:
                    return null;
            }}
        }}

        protected override bool TryParseCase(in ReadOnlySpan<char> name, out {tn} result)
        {{
            switch (name)
            {{
{string.Join("\r\n", enumMembers.Select(i => @$"                case ReadOnlySpan<char> current when current.Equals(nameof({tn}.{i.Name}).AsSpan(), global::System.StringComparison.Ordinal):
                    result = {tn}.{i.Name};
                    return true;"))}
                default:
                    result = default;
                    return false;
            }}
        }}

        protected override bool TryParseIgnoreCase(in ReadOnlySpan<char> name, out {tn} result)
        {{
            switch (name)
            {{
{string.Join("\r\n", enumMembers.Select(i => @$"                case ReadOnlySpan<char> current when current.Equals(nameof({tn}.{i.Name}).AsSpan(), global::System.StringComparison.OrdinalIgnoreCase):
                    result = {tn}.{i.Name};
                    return true;"))}
                default:
                    result = default;
                    return false;
            }}
        }}
    }}
";
            return ($"global::SV.Enums.SetEnumInfo<{tn}>(new {name}());", src);
        }

        private INamedTypeSymbol TransformEnum(GeneratorSyntaxContext context, CancellationToken token)
        {
            try
            {
                if (context.Node is not EnumDeclarationSyntax ie
                        || context.SemanticModel.GetDeclaredSymbol(ie, token) is not INamedTypeSymbol nType)
                {
                    return null;
                }

                return nType;
            }
            catch (Exception ex)
            {
                Debug.Fail(ex.Message);
                return null;
            }
        }

        private bool FilterEnum(SyntaxNode node, CancellationToken token)
        {
            return node is EnumDeclarationSyntax;
        }
    }
}